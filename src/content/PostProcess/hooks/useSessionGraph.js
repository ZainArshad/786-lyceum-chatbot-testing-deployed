import { useMemo, useState, useEffect } from 'react';
import {
	selectPPNodes,
	selectPPLimits,
} from 'src/slices/postProcessing/graphs';
import { useSelector } from 'src/store';
import { shallowEqual } from 'react-redux';
import _ from 'lodash';
import { useTranslation } from 'next-i18next';
import {
	convertEntry,
	generateAppPayload,
	getLimitLineConf,
	getPassingAndFailingNodes,
	limitIsOkayToDraw,
	getAutoGenLimitLineConf,
	autoGenerateLimits,
} from 'src/lib/helpers/graphs/postProcessing';
import { LIMIT_LINE_RED_COLOR as RED_COLOR } from 'src/lib/constants/graphs';
import { useRefMounted } from 'src/hooks/useRefMounted';
import { useLimitQuery } from 'src/queries/postProcess/limits';
import { LOWER_LIMIT_TYPE, UPPER_LIMIT_TYPE } from 'src/lib/constants/common';
import { useNodesQuery } from 'src/queries/postProcess/nodes';
import { LOWERL_LIMIT, UPPERL_LIMIT } from '../constants';

/**
 * Hook that is responsible for rendering all the data`
 * on the graph with applied options
 * @param {{graphId: string}} param0
 * @returns {{
 *  data: {datasets: Array<{data: Array<{x: number, y: number}>}>},
 *  isLoading: boolean,
 *  fetchStatus: "idle" | "loading" | "error" | "success",
 *  isSuccess: boolean,
 *  isError: boolean,
 *  hasNodes: boolean,
 *  refetch: () => void,
 * }}
 */
export const useSessionGraph = ({ graphId }) => {
	const defaultLims = { upperLimits: { data: [] }, lowerLimits: { data: [] } };
	const { t } = useTranslation();
	const mounted = useRefMounted();
	const handleDefaultShallowEqual = (left, right) =>
		shallowEqual(left[graphId], right[graphId]);
	const selectedNodes = useSelector((state) => {
		const nodes = selectPPNodes(state);
		return nodes[graphId];
	});
	const {
		upperLimit,
		lowerLimit,
		showFailing,
		showPassing,
		processId,
		fetchId,
	} = useSelector(selectPPLimits, handleDefaultShallowEqual)[graphId];

	const ul = upperLimit.points;
	const ll = lowerLimit.points;

	const hasNodes = !_.isEmpty(selectedNodes);
	const generateRequestPayload = () => convertEntry(selectedNodes);

	const [autoGeneratedUpperLimit, setAutoGeneratedUpperLimit] = useState({
		data: [],
	});
	const [autoGeneratedLowerLimit, setAutoGeneratedLowerLimit] = useState({
		data: [],
	});

	const generateNodesPayload = () => {
		const p = generateRequestPayload();
		const res = [];
		Object.entries(p).forEach(([projectId, category]) => {
			if (typeof category === 'object') {
				Object.entries(category).forEach(([categoryId, nodeIds]) => {
					res.push({ projectId, categoryId, nodeIds });
				});
			}
		});
		return res;
	};

	const nodesQuery = useNodesQuery(generateNodesPayload());

	const {
		data: loadedLimits,
		isSuccess: successLoadedLims,
		status: loadLimitStatus,
	} = useLimitQuery(fetchId, {
		select: (data) => {
			if (!data?.limits) {
				return defaultLims;
			}
			const { limits } = data;
			let res = defaultLims;
			limits.forEach((limit) => {
				if (limit.limit_types === UPPER_LIMIT_TYPE) {
					res.upperLimits = getLimitLineConf(
						t('Upper Limit'),
						generateAppPayload(limit.limit),
						RED_COLOR,
						UPPER_LIMIT_TYPE
					);
				} else if (limit.limit_types === LOWER_LIMIT_TYPE) {
					res.lowerLimits = getLimitLineConf(
						t('Lower Limit'),
						generateAppPayload(limit.limit),
						RED_COLOR,
						LOWER_LIMIT_TYPE
					);
				}
			});
			return res;
		},
	});

	const triggerAutogenerateUpperLimit = () => {
		const dsup = autoGenerateLimits({
			dataset: getDataSets,
			limitType: UPPERL_LIMIT,
			sigma: upperLimit.sigma,
		});
		setAutoGeneratedUpperLimit(
			getAutoGenLimitLineConf('AUL', dsup, UPPER_LIMIT_TYPE)
		);
	};

	const triggerAutogenerateLowerLimit = () => {
		const dsll = autoGenerateLimits({
			dataset: getDataSets,
			limitType: LOWERL_LIMIT,
			sigma: upperLimit.sigma,
		});
		setAutoGeneratedLowerLimit(
			getAutoGenLimitLineConf('ALL', dsll, LOWER_LIMIT_TYPE)
		);
	};

	useEffect(() => {
		if (!nodesQuery.data || !mounted()) {
			return;
		}
		if (!fetchId && upperLimit.isAutogenerating) {
			triggerAutogenerateUpperLimit();
		}
		if (!fetchId && lowerLimit.isAutogenerating) {
			triggerAutogenerateLowerLimit();
		}
	}, [processId]);

	useEffect(() => {
		if (!nodesQuery.data) {
			return;
		}
		if (
			!fetchId &&
			upperLimit.isAutogenerating &&
			autoGeneratedUpperLimit.data.length === 0
		) {
			triggerAutogenerateUpperLimit();
		}
		if (
			!fetchId &&
			lowerLimit.isAutogenerating &&
			autoGeneratedLowerLimit.data.length === 0
		) {
			triggerAutogenerateLowerLimit();
		}
	}, [nodesQuery.isFetching]);

	useEffect(() => {
		if (!upperLimit.isAutogenerating) {
			setAutoGeneratedUpperLimit({ data: [] });
		}
		if (!lowerLimit.isAutogenerating) {
			setAutoGeneratedLowerLimit({ data: [] });
		}
	}, [upperLimit.isAutogenerating, lowerLimit.isAutogenerating]);

	const getDataSets = useMemo(() => {
		if (!nodesQuery.data) return [];
		const dataSets = [];
		nodesQuery.data.forEach((device) => {
			dataSets.push({
				label: device.device.name,
				data: generateAppPayload(device.device_data),
				backgroundColor: device.backgroundColor,
				borderColor: device.borderColor,
				pointRadius: 0,
				fill: false, // change to true if want colored background
				type: 'line',
			});
		});
		return dataSets;
	}, [nodesQuery.isFetching, nodesQuery.triggerKey]);

	const processForPassingAndFailingPoints = useMemo(() => {
		if (!nodesQuery.isSuccess)
			return { dataset: getDataSets, passing: [], failing: [] };
		const decidedUpperLimit =
			!!fetchId && successLoadedLims
				? loadedLimits.upperLimits.data || []
				: upperLimit.isAutogenerating
				? autoGeneratedUpperLimit.data || []
				: ul;

		const decidedLowerLimit =
			!!fetchId && successLoadedLims
				? loadedLimits.lowerLimits.data || []
				: lowerLimit.isAutogenerating
				? autoGeneratedLowerLimit.data || []
				: ll;
		try {
			const g = getPassingAndFailingNodes({
				dataset: getDataSets,
				upperLimits: decidedUpperLimit,
				lowerLimits: decidedLowerLimit,
			});
			return g;
		} catch (error) {
			console.error(error);
			return { dataset: getDataSets, passing: [], failing: [] };
		}
	}, [
		ul,
		ll,
		processId,
		autoGeneratedUpperLimit,
		autoGeneratedLowerLimit,
		fetchId,
		loadLimitStatus,
		nodesQuery.triggerKey,
		nodesQuery.isFetching,
	]);

	const limitDataSets = () => {
		if (!nodesQuery.data) return [];
		const lDataSets = [];

		if (fetchId && !successLoadedLims) {
			lDataSets.push(getLimitLineConf(t('Loading...'), [], RED_COLOR));
			return lDataSets;
		}

		if (fetchId && successLoadedLims) {
			if (loadedLimits.upperLimits?.data?.length) {
				lDataSets.push(loadedLimits.upperLimits || []);
			}
			if (loadedLimits.lowerLimits?.data?.length) {
				lDataSets.push(loadedLimits.lowerLimits || []);
			}
			return lDataSets;
		}

		if (upperLimit.isAutogenerating) {
			lDataSets.push(autoGeneratedUpperLimit);
		} else if (limitIsOkayToDraw(ul)) {
			lDataSets.push(
				getLimitLineConf(t('Upper Limit'), ul, RED_COLOR, UPPER_LIMIT_TYPE)
			);
		}
		if (lowerLimit.isAutogenerating) {
			lDataSets.push(autoGeneratedLowerLimit);
		} else if (limitIsOkayToDraw(ll)) {
			lDataSets.push(
				getLimitLineConf(t('Lower Limit'), ll, RED_COLOR, LOWER_LIMIT_TYPE)
			);
		}

		return lDataSets;
	};

	const generateGraphPayload = () => {
		if (!nodesQuery.data) return [];
		const gPoints = processForPassingAndFailingPoints;
		const limitDS = limitDataSets();
		if (showFailing && showPassing) {
			return [...gPoints.dataset, ...limitDS];
		}
		if (showFailing) {
			return [...gPoints.failing, ...limitDS];
		}
		if (showPassing) {
			return [...gPoints.passing, ...limitDS];
		}
		return [...gPoints.dataset, ...limitDS];
	};

	const data = { datasets: [...generateGraphPayload()] };

	return {
		data,
		isLoading: nodesQuery.isLoading,
		isIdle: nodesQuery.isIdle,
		isSuccess: nodesQuery.isSuccess,
		isError: nodesQuery.isError,
		hasNodes,
		refetch: nodesQuery.refetch,
	};
};
